[{"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\index.ts":"1","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\constants.ts":"2","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\scenes\\walletScene.ts":"3","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\scenes\\labScene.ts":"4","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\vrfProvider.ts":"5","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\actors\\enemy.ts":"6","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\wallet.ts":"7","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\scenes\\gameScene.ts":"8","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\actors\\player.ts":"9","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\contractAbi\\index.js":"10","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\actors\\character.ts":"11","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\contractAbi\\queries.js":"12","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\contractAbi\\avatar.js":"13","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\contractAbi\\board.js":"14","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\config.ts":"15","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\assets\\helpers.ts":"16"},{"size":767,"mtime":1649292390507,"results":"17","hashOfConfig":"18"},{"size":1436,"mtime":1649033792476,"results":"19","hashOfConfig":"18"},{"size":15584,"mtime":1649727733753,"results":"20","hashOfConfig":"18"},{"size":16369,"mtime":1649727237891,"results":"21","hashOfConfig":"18"},{"size":335,"mtime":1649025091777,"results":"22","hashOfConfig":"18"},{"size":2441,"mtime":1649718865171,"results":"23","hashOfConfig":"18"},{"size":1363,"mtime":1649025091778,"results":"24","hashOfConfig":"18"},{"size":3605,"mtime":1649297626619,"results":"25","hashOfConfig":"18"},{"size":2077,"mtime":1649718875028,"results":"26","hashOfConfig":"18"},{"size":3290,"mtime":1649721229054,"results":"27","hashOfConfig":"18"},{"size":8463,"mtime":1649718849368,"results":"28","hashOfConfig":"18"},{"size":1593,"mtime":1649025091768,"results":"29","hashOfConfig":"18"},{"size":13362,"mtime":1649025091767,"results":"30","hashOfConfig":"18"},{"size":7178,"mtime":1649025091767,"results":"31","hashOfConfig":"18"},{"size":559,"mtime":1649728054103,"results":"32","hashOfConfig":"18"},{"size":534,"mtime":1649726835718,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"1lywk4k",{"filePath":"37","messages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"36"},{"filePath":"44","messages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"46","messages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"57","messages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"59","messages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"56"},{"filePath":"62","messages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\index.ts",[],["70","71"],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\constants.ts",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\scenes\\walletScene.ts",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\scenes\\labScene.ts",["72"],"import EasyStar from 'easystarjs';\n//import { AbiCoder } from 'ethers/lib/utils';\nimport Phaser from 'phaser';\n\nimport Enemy from '../actors/enemy';\nimport Player from '../actors/player';\nimport dialogue from '../assets/dialogue.json';\nimport { getPublicUrl } from '../assets/helpers';\nimport * as constants from '../constants';\nimport { NUM_ENEMIES, TILEHEIGHT, TILEWIDTH } from '../constants';\nimport { completeBoard, startBoard } from '../contractAbi'\nimport { BoardMeta } from '../types';\nimport { VrfProvider } from '../vrfProvider';\nimport { GameScene } from './gameScene';\nimport { WalletScene } from './walletScene';\n\nconst GAME_MODE = Object.freeze({ OFFLINE: 1, ONLINE:2 });\nconst COLLISION_INDEX_START = 54;\nconst COLLISION_INDEX_END = 83;\nconst ENEMY_SPRITE_SIZE_PX = 64;\nconst WALKABLE_RANGES = [\n    [1, 3], [26, 28], [51, 53], [76, 78], [101, 103], [126, 128], [183, 185], [189, 200]\n];\nconst COLLIDING_RANGES = [\n    [4, 25], [29, 50], [54, 75], [79, 100], [104, 125], [129, 182], [186, 188]\n];\nconst PATHFINDER_ITERATIONS = 1000;\n\nexport class LabScene extends GameScene {\n    //////////////// PHASER LIFECYLE //////////////////////////\n\n    preload() {\n        this.load.image('tiles', getPublicUrl('/tilemaps/tiles/factory64x64.png'));\n        this.load.tilemapCSV('map', getPublicUrl('/tilemaps/csv/lab1.csv'));\n        this.load.spritesheet('player', getPublicUrl('/sprites/scientist_game.png'), { frameWidth: TILEWIDTH, frameHeight: TILEHEIGHT });\n        for (let i = 0; i < NUM_ENEMIES; i++) {\n            this.load.spritesheet(\n                'enemy_' + i,\n                getPublicUrl('/sprites/droids_sprite_64x64.png'),\n                {\n                    frameWidth: ENEMY_SPRITE_SIZE_PX,\n                    frameHeight: ENEMY_SPRITE_SIZE_PX,\n                    startFrame: 2 * i,\n                    endFrame: 2 * i + 1\n                }\n            );\n        }\n        this.load.spritesheet('damageSprites', getPublicUrl('/animations/explosionSheet.png'), { frameWidth: 32, frameHeight: 32 });\n    }\n\n    create() {\n        this.pathfinder = new EasyStar.js();\n\n        // LOAD MAP \n        this.map = this.make.tilemap({ key: 'map', tileWidth: TILEWIDTH, tileHeight: TILEHEIGHT });\n        this.tileset = this.map.addTilesetImage('tiles');\n        const layer = this.map.createLayer(0, this.tileset, 0, 0);\n        this.map.setCollisionBetween(COLLISION_INDEX_START, COLLISION_INDEX_END);\n        this.pathfinder.setGrid(this.buildPathfindingGrid());\n        this.pathfinder.setAcceptableTiles(this.buildAcceptableTileList());\n        // so that we can call this in the update loop\n        this.pathfinder.enableSync();\n        // we recalculate every turn... keeping this low for now\n        this.pathfinder.setIterationsPerCalculation(PATHFINDER_ITERATIONS);\n        this.vrfProvider = new VrfProvider();\n\n        // SPAWN SPRITES\n        this.player = new Player(\n            this,\n            2,\n            5,\n            'player',\n            0, // frame\n            this.getPlayerConfig(),\n            this.vrfProvider);\n        this.collidingGameObjects.push(this.player);\n\n        for (let i = 0; i < NUM_ENEMIES; i++) {\n            const enemyXY = this.getEnemySpawnPosition(i);\n            const enemy = new Enemy(\n                this,\n                enemyXY[0],\n                enemyXY[1],\n                'enemy_' + i,\n                i * 2, //frame\n                this.getEnemyConfig(), \n                this.vrfProvider);\n\n            enemy.scaleX = TILEWIDTH / ENEMY_SPRITE_SIZE_PX;\n            enemy.scaleY = TILEHEIGHT / ENEMY_SPRITE_SIZE_PX;\n            this.enemies.push(enemy);\n            this.collidingGameObjects.push(enemy);\n        }\n\n        // INITIALIZE ANIMATIONS\n        this.anims.create({\n            key: \"damageAnimation\",\n            //frameRate:, \n            frames: this.anims.generateFrameNumbers(\"damageSprites\", {}),\n            repeat: 0\n        });\n\n        this.physics.add.collider(this.player, layer);\n\n        // INITIALIZE HISTORY\n        this.moveHistory.push([this.player.tileX(), this.player.tileY(), false]);\n        this.enemies.forEach(enemy => {\n            this.moveHistory.push([enemy.tileX(), enemy.tileY(), false]);\n        });\n\n        // CONFIGURE CAMERA\n        this.cameras.main.setBounds(0, 0, this.map.widthInPixels, this.map.heightInPixels);\n\n        // INIT INPUT\n        this.cursors = this.input.keyboard.createCursorKeys();\n\n        // INIT UI / UX\n        const turnsRemainingText = this.add.text(0, 0, \"TURNS REMAINING: XX\", {\n            fontSize: constants.TURNS_REMAINING_FONT_SIZE_STRING,\n            fontFamily: constants.TURNS_REMAINING_FONT_FAMILY,\n            color: \"#fff\",\n            backgroundColor: \"#000\"\n        });\n        turnsRemainingText.setPosition(\n            (constants.VIEWPORT_WIDTH - turnsRemainingText.width) / 2,\n            constants.VIEWPORT_HEIGHT - turnsRemainingText.height);\n        turnsRemainingText.setAlpha(0);\n\n        this.textSprites.turnsRemaining = turnsRemainingText;\n    }\n\n    update (time: number, delta: number) {\n        // block until either:\n        //      wallet is connected & on-chain state retrieved <---- ONLINE mode\n        // OR   opted-out of wallet, default offline state used <---- OFFLINE mode\n        if (!this.initGameState()) {\n            let { modeSelectPrompt } = this.textSprites;\n            if (modeSelectPrompt == null) {\n                modeSelectPrompt = this.add.text(\n                    0,\n                    0,\n                    constants.CONNECT_PROMPT_TEXT,\n                    {fontSize: '22px', backgroundColor:\"#000\", color: \"#fff\"});\n                modeSelectPrompt.setPosition((constants.VIEWPORT_WIDTH - modeSelectPrompt.width) / 2, 80);\n                this.textSprites.modeSelectPrompt = modeSelectPrompt;\n            }\n            return;\n        }\n\n        if (this.textSprites.modeSelectPrompt != null) {\n            this.textSprites.modeSelectPrompt.destroy();\n            delete this.textSprites.modeSelectPrompt;\n        }\n \n        if (!this.hasGameStarted()){\n            return;\n        }\n\n        if (!this.gameStarted) {\n            this.startGame();\n            this.gameStarted = true;\n        }\n \n        const input = this.gameOver ? constants.INPUT.NONE : this.getInput(time);\n        \n        // update sprites\n        this.player?.update(input);\n\n        if (input !== constants.INPUT.NONE) {\n            this.decrementTurnsRemaining();\n        }\n\n        // update enemies \n        const allEnemiesDead = this.enemies.every(enemy => enemy.isDead());\n        this.endGameIfOver(allEnemiesDead);\n    }\n\n    // TODO: add menu or visual prompt before sending a txn using user's wallet\n    hasGameStarted() {\n        if (this.gameMode === GAME_MODE.OFFLINE) {\n            // no extra interaction necessary if wallet isn't connected\n            return true;\n        }\n        if (this.gameMode === GAME_MODE.ONLINE) {\n            // send prompt to user\n\n            // wait for user to affirm prompt \n            return true;\n        }\n\n        return false;\n    }\n\n    startGame() {\n        const remaining = this.textSprites.turnsRemaining;\n        remaining?.setAlpha(1);\n        remaining?.setText(constants.TURNS_REMAINING_TEXT + \" \" + this.turnsRemaining);\n        remaining?.setAlpha(1);\n        if (this.gameMode === GAME_MODE.OFFLINE || this.currentGame !== null) {\n            console.log(\"offline mode enabled or game is in progress\");\n            this.vrfProvider?.setSeed(this.getOfflineBoard());\n            return; \n        }\n        console.log(\"starting game on-chain\");\n        const avatarId = this.avatar?.id;\n        startBoard(this.provider, this.board, avatarId).then(\n            (results) => {\n                if (results) {\n                    const [gameId, gameData] = results;\n                    console.log(\"retrieved on-chain gameId: %s and gameData \", gameId, gameData);\n                    this.gameId = gameId;\n                    this.gameData = gameData;\n                    // TODO: get the seed from character sheet\n                    this.vrfProvider?.setSeed(this.gameData.seed);\n                }\n            });\n\n    }\n\n    endGame() {\n        console.log(\"ending game on-chain\");\n        if (this.gameMode === GAME_MODE.OFFLINE)\n            return; \n\n        completeBoard(this.provider, this.board, this.gameId, this.gameData);\n    }\n\n    endGameIfOver(allEnemiesDead: boolean) {\n        let terminal = false;\n        let victory = false;\n\n        if (allEnemiesDead) {\n            terminal = true;\n            victory = true;\n        }\n        else if (this.player?.isDead()) {\n            // animation\n            terminal = true;\n        }\n        else if (this.haveMaxTurnsElapsed()) {\n            // animation\n            terminal = true;\n        }\n\n        if (!terminal || this.gameOver)\n            return false;\n        \n        this.gameOver = true;\n        \n        if (this.gameMode === GAME_MODE.OFFLINE) {\n            if (victory) {\n                this.animateVictory();\n                // dispaly a \"here's what you *would* win prompt\"\n            } else {\n                this.animateDefeat(this.haveMaxTurnsElapsed());\n            }\n        }\n        if (this.gameMode === GAME_MODE.ONLINE) {\n            this.gameData.completed = true;\n            if (victory) {\n                this.gameData.victory = true;\n                // submit result + end game\n\n                // claim NFT\n\n                // submit ZK history\n            } else {\n                // update game state\n                this.gameData.victory = false;\n                this.gameData.resign = this.haveMaxTurnsElapsed();\n                this.animateDefeat(this.haveMaxTurnsElapsed());\n\n                // animate damage to equipped loot\n                this.animateLootDamage(1);\n            }\n        }\n\n        return true;\n    }\n\n    /////////////////////////////////////////////\n\n    getEnemySpawnPosition(enemyIndex: number): [number, number] {\n        switch (enemyIndex) {\n            case 0:\n                return [7, 4];\n            case 1:\n                return [15, 1];\n            case 2:\n                return [20, 10];\n            default:\n                return [-1, -1];\n        }\n    }\n\n    //////////// TILING & NAVIGATION //////////////////\n    getTileID(x: number, y: number): number {\n        return this.map?.getTileAt(x, y)?.index ?? -1;\n    }\n\n    // checks if a tile at coordinate x,y has collision enabled\n    doesTileCollide(x: number, y: number): boolean {\n        const nextTile = this.map?.getTileAt(x, y) || null;\n        return nextTile == null || this.doesTileIDCollide(nextTile.index);\n    }\n\n    doesTileIDCollide(index: number): boolean {\n        return this.map?.tilesets[0]?.tileProperties.hasOwnProperty(index + 1) || true;\n    }\n\n    buildPathfindingGrid() {\n        const grid = [];\n        const height = this.map?.height ?? -1;\n        const width = this.map?.width ?? -1;\n        for (let y = 0; y < height; y++) {\n            const col = [];\n            for (let x = 0; x < width; x++) {\n                // In each cell we store the ID of the tile, which corresponds\n                // to its index in the tileset of the map (\"ID\" field in Tiled)\n                col.push(this.getTileID(x, y));\n            }\n            grid.push(col);\n        }\n        return grid;\n    }\n\n    buildAcceptableTileList() {\n        const acceptableTiles = [];\n        const tileset = this.map?.tilesets[0] || null;\n        if (tileset) {\n            let properties = tileset.tileProperties as Record<string, any>;\n\n            // iterate manually set ranges for collision\n            COLLIDING_RANGES.forEach(range => {\n                for (let i = range[0]; i <= range[1]; i++) {\n                    properties[i] = { collide: true };\n                }\n            });\n\n            for (let i = tileset.firstgid; i < tileset.total; i++) { // firstgid and total are fields from Tiled that indicate the range of IDs that the tiles can take in that tileset\n                if (!properties.hasOwnProperty(i + 1)) acceptableTiles.push(i);\n            }\n        }\n        return acceptableTiles\n    }\n\n    //////////ON-CHAIN INTERACTIONS////////////\n\n    /// returns true if:\n    ///     offline mode is selected \n    /// OR  wallet is connected, avatar selected, board state retrieved\n    /// and false otherwise  \n    initGameState() {\n        // If the game mode has been set, then the requisited state has been\n        //  retrieved\n        if (this.gameMode === GAME_MODE.OFFLINE || this.gameMode === GAME_MODE.ONLINE)\n            return true;\n\n        let initialized = false;\n        // check via the scene manager if the user has connected to the wallet scene\n        const walletScene = this.scene.manager.getScene('wallet') as WalletScene;\n\n        // check if the user has either opted for offline play, or connected a wallet and avatar\n        if (walletScene.provider !== null && walletScene.currentAvatar !== null && walletScene.board !== null) {\n            this.provider = walletScene.provider;\n            this.avatar = walletScene.currentAvatar;\n            this.board = walletScene.board;\n            this.gameMode = GAME_MODE.ONLINE;\n            initialized = true;\n        }\n        else if (walletScene.offline) {\n            this.avatar = this.getOfflineAvatar();\n            this.board = this.getOfflineBoard();\n            this.gameMode = GAME_MODE.OFFLINE;\n            initialized = true;\n        }\n\n        if (initialized && this.avatar) {\n            this.initGameStateFromBoard(this.board);\n            this.player?.initStatsFromAvatar(this.avatar);\n        }\n\n        return initialized;\n    }\n\n    initGameStateFromBoard(board: BoardMeta) {\n        if (!board) {\n            console.warn(\"unexpected state, should have a board\");\n            return;\n        }\n        this.enemies.forEach(enemy => {\n            if (this.gameMode === GAME_MODE.OFFLINE) {\n                enemy.initOfflineStats();\n            }\n            if (this.gameMode === GAME_MODE.ONLINE) {\n                enemy.initStats(board);\n            }\n        });\n\n        if (this.gameMode === GAME_MODE.OFFLINE)\n            this.turnsRemaining = 50;\n        //TODO\n        if (this.gameMode === GAME_MODE.ONLINE)\n            this.turnsRemaining = 50;\n    }\n\n    getOfflineAvatar() {\n        return JSON.parse(\n            '[{\"id\":\"0x0\",\"fields\":{\"name\":\"Alcibiades\",\"description\":\"An avatar ready to fight moloch.\",\"image\":\"ipfs://bafkreib4ftqeobfmdy7kvurixv55m7nqtvwj3o2hw3clsyo3hjpxwo3sda\",\"attributes\":[{\"trait_type\":\"HP\",\"value\":3},{\"trait_type\":\"AP\",\"value\":1},{\"trait_type\":\"DP\",\"value\":0},{\"trait_type\":\"Armor\",\"value\":\"Worn Lab Coat\"},{\"trait_type\":\"Weapon\",\"value\":\"Used Plasma Cutter\"},{\"trait_type\":\"Implant\",\"value\":\"No Implant\"},{\"trait_type\":\"Experience\",\"value\":0}]}},0]'\n        );\n    }\n\n    getOfflineBoard() {\n        return {maxTurns: 50};\n    }\n\n    /////////EMBELLISHMENTS/////////\n    getEnemyConfig() {\n        return {\n            \"dialogue\": dialogue.enemy\n        };\n    }\n\n    getPlayerConfig() {\n        return {\n            \"dialogue\": dialogue.player\n        };\n    }\n\n    animateVictory() {\n        const { player } = this;\n        if (!player) return;\n        player.animateText(\"YOU HAVE VANQUISHED MOLOCH!\", player.x, player.y, \"#D4AF37\", 50);\n    }\n\n    animateDefeat(ranOutOfTurns: boolean) {\n        // TODO\n    }\n\n    animateLootDamage(damage: number) {\n        // TODO\n    }\n    //////////DEBUG///////////////\n\n    drawDebug() {\n        if (this.debugGraphics) {\n            this.debugGraphics.clear();\n\n            if (this.showDebug && this.debugGraphics) {\n                // Pass in null for any of the style options to disable drawing that component\n                this.map?.renderDebug(this.debugGraphics, {\n                    tileColor: null, // Non-colliding tiles\n                    collidingTileColor: new Phaser.Display.Color(243, 134, 48, 200), // Colliding tiles\n                    faceColor: new Phaser.Display.Color(40, 39, 37, 255) // Colliding face edges\n                });\n            }\n\n            this.helpText?.setText(this.getHelpMessage());\n        }\n    }\n\n    getHelpMessage() {\n        return 'Arrow keys to move.' +\n            '\\nPress \"C\" to toggle debug visuals: ' + (this.showDebug ? 'on' : 'off');\n    }\n}\n","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\vrfProvider.ts",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\actors\\enemy.ts",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\wallet.ts",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\scenes\\gameScene.ts",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\actors\\player.ts",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\contractAbi\\index.js",[],["73","74"],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\actors\\character.ts",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\contractAbi\\queries.js",["75"],"import Crypto from 'crypto-js';\r\nimport { gql, request } from 'graphql-request';\r\n\r\nimport { GRAPH_ENDPOINTS, USER_TOKEN_Q } from '../config';\r\n\r\nexport function base64ToJSON(bytes) {\r\n  const str = Crypto.enc.Base64.parse(bytes).toString(Crypto.enc.Utf8);\r\n  return JSON.parse(str);\r\n}\r\n\r\n/* let client = null;\r\n\r\nexport async function getClient(provider) {\r\n  if (client) {\r\n    return client;\r\n  }\r\n  const network = await provider.getNetwork();\r\n\r\n  const chainId = `0x${network.chainId.toString(16)}`;\r\n  const endpoint = GRAPH_ENDPOINTS[chainId];\r\n  const cache = new InMemoryCache();\r\n  client = new ApolloClient({\r\n    // Provide required constructor fields\r\n    cache: cache,\r\n    uri: endpoint,\r\n  });\r\n  return client;\r\n}; */\r\n\r\nexport async function getTokens(provider, address) {\r\n  const network = await provider.getNetwork();\r\n  const chainId = `0x${network.chainId.toString(16)}`;\r\n  const endpoint = GRAPH_ENDPOINTS[chainId];\r\n  const query = gql`\r\n query UserTokens($owner: String!) {\r\n  tokens(owner: $owner) {\r\n    id,\r\n    owner,\r\n    uri\r\n  }\r\n}\r\n`;\r\n  const data = await request(endpoint, query, { owner: address });\r\n  console.log('data', data);\r\n  const avatars = data.tokens.map(token => {\r\n    const uri = token.uri || \"\";\r\n    let fields = {};\r\n    const parts = uri.split(\"base64,\")\r\n    if (parts.length > 1) {\r\n      try {\r\n        console.log('decoding', parts[1]);\r\n        fields = base64ToJSON(parts[1]);\r\n      } catch (e) {\r\n        console.error(e);\r\n      }\r\n    }\r\n    return {\r\n      id: token.id,\r\n      fields,\r\n    }\r\n  });\r\n  return avatars;\r\n}\r\n\r\n","C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\contractAbi\\avatar.js",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\contractAbi\\board.js",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\config.ts",[],"C:\\Users\\bkroe\\work\\CoinOp\\moloch-rises\\src\\assets\\helpers.ts",[],{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","replacedBy":"79"},{"ruleId":"80","severity":1,"message":"81","line":21,"column":7,"nodeType":"82","messageId":"83","endLine":21,"endColumn":22},{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","replacedBy":"79"},{"ruleId":"84","severity":1,"message":"85","line":4,"column":27,"nodeType":"82","messageId":"83","endLine":4,"endColumn":39},"no-native-reassign",["86"],"no-negated-in-lhs",["87"],"@typescript-eslint/no-unused-vars","'WALKABLE_RANGES' is assigned a value but never used.","Identifier","unusedVar","no-unused-vars","'USER_TOKEN_Q' is defined but never used.","no-global-assign","no-unsafe-negation"]